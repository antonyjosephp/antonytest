import * as api from '@opentelemetry/api';
import { propagation } from '@opentelemetry/api';
import { W3CTraceContextPropagator } from '@opentelemetry/core';

import { Logger } from '../logUtil/logger';
import { LogLevel } from '../logUtil/LogLevel';

//const GCP_PROJECT_NAME = process.env.GOOGLE_PROJECT;
//const GCP_PROJECT_LOG_NAME = process.env.GOOGLE_PROJECT_LOG_NAME;
/**
 * @description - Post span creation returns, this interface which has carrier information for propagation and the generated TraceID for span
 */

interface SpanData {
    carrier: any;
    generatedTraceId: any;
}

/**
 *
 * @param spanName - Name of the Span to create.
 * @param isPropagationRequired - TRUE : If the Context has to be propogated to next call / FALSE : Otherwise.
 * @param contextToBeUsed - The context with which the new span will be created.
 * @returns  Interface Type of spanData, that has carrier and traceid information
 */
function createSpanByName(spanName: string, isPropagationRequired: boolean, contextToBeUsed: api.Context) {
    try {
        //throw new Error('Custom Error');
        let returnSpanData: SpanData;
        const curContext = contextToBeUsed;
        const apiSpan = api.trace.getTracer('ims-boiler-plate-frontend').startSpan(spanName, {}, curContext);
        apiSpan.setAttribute('app-name', 'gcp-otel-tester');
        const returnTraceId = api.trace.getSpanContext(curContext)?.traceId;
        if (isPropagationRequired) {
            let carrier: any = {};
            const tracePropagator = new W3CTraceContextPropagator();
            tracePropagator.inject(
                api.trace.setSpanContext(curContext, apiSpan.spanContext()),
                carrier,
                api.defaultTextMapSetter
            );
            returnSpanData = { carrier: carrier, generatedTraceId: returnTraceId };

            const message = JSON.stringify({
                severity: LogLevel.INFO,
                pageName: 'app/api/route',
                logMessage: 'Created Span by name ' + spanName + ' with TraceID =  ' + returnTraceId,
                additionalParameters: {
                    'Additional Param 1': 'Value',
                    'Additional Param 2': 'value',
                },
            });
            Logger.writeLog(message);

            apiSpan.end();
            return returnSpanData;
        } else {
            const message = JSON.stringify({
                severity: LogLevel.INFO,
                pageName: 'app/api/route',
                logMessage: 'Created Span by name ' + spanName + ' with TraceID =  ' + returnTraceId,
                additionalParameters: {
                    'Additional Param 1': 'Value',
                    'Additional Param 2': 'value',
                },
            });
            Logger.writeLog(message);

            returnSpanData = { carrier: '', generatedTraceId: returnTraceId };
            apiSpan.end();
            return returnSpanData;
        }
    } catch (error: unknown) {
        if (error instanceof Error) {
            const message = JSON.stringify({
                stackTrace: error.stack,
                errorMessage: error.message,
                additionalParameters: {
                    'Additional Information ': 'This is the error generated by traceUtility',
                },
            });
            Logger.logError(message);
        }
    }
}

/**
 *
 * @param spanName - Name of the Span to create.
 * @param carrier - Propagation Carrier information consisitng of "Parent" TraceID from the context being passed
 * @param isPropagationRequired - TRUE : If the Context has to be propogated to next call / FALSE : Otherwise.
 * @returns  Interface Type of spanData, that has carrier and traceid information
 */
function createSpanByPropagatingContext(spanName: string, carrier: any, isPropagationRequired: boolean) {
    let activeContext: api.Context = propagation.extract(carrier.context.active(), carrier);
    const returnSpanData = createSpanByName(spanName, isPropagationRequired, activeContext);
    return returnSpanData;
}

export { createSpanByName, createSpanByPropagatingContext };
export type { SpanData };
